---
layout: post
title: test
subtitle: sshd, Meme Maker 3000, aray, checksum, frog
thumbnail-img: /assets/img/writeups/202411/4.png
tags: [Writeup, Reversing]
comments: true
ctf: Flare-On 11
color: FFB6B6
ctf_date: 2024-10-27
probs:
  - [frog, 1, Reversing, Warming Up]
  - [checksum, 2, Reversing, Golang]
  - [aray, 3, Reversing, Yara Rule]
  - [Meme Maker 3000, 4, Reversing, JavaScript Obfuscation]
  - [sshd, 5, Reversing, CoreDump]
---

# sshd

linux filesystem dump가 주어진다. 시나리오는 다음과 같다.

Our server in the FLARE Intergalactic HQ has crashed! Now criminals are trying to sell me my own data!!! Do your part, random internet hacker, to help FLARE out and tell us what data they stole! We used the best forensic preservation technique of just copying all the files on the system for you.

## 코어 덤프

문제에서 일반적인 로그 파일`/var/log 하위` 은 모두 지워져 있고, `journal` 관련 파일도 존재하지 않았다. 대신 문제 시나리오 상의 `server has crashed`라는 단서 조항에서 착안하여, 관련된 코어 덤프를 확인할 수 있었다. 

`sshd`와 관련된 `core dump`이므로 `gdb`로 아래와 같이 분석한다. 참고로 `ssh_container` 최상위 위치에서 반드시 `set sysroot .`를 하여야 문제에서 주어진 파일 시스템을 기반으로 `breaktrace`를 얻을 수 있다. 그렇지 않으면 로컬 호스트 파일 시스템 기반으로 `gdb`가 동작하여 제대로 된 `symbol`을 얻을 수 없다.

```cpp
[.../ssh_container]
$ gdb -c ./var/lib/systemd/coredump/sshd.core.93794.0.0.11.1725917676 ./usr/sbin/sshd
(gdb) set sysroot .
(gdb) bt full
...
#1  0x00007f4a18c8f88f in ?? () from ./lib/x86_64-linux-gnu/liblzma.so.5
No symbol table info available.
...
#9  0x00007f4a18e5824a in __libc_start_call_main (main=main@entry=0x55b46c6e7d50, 
    argc=argc@entry=4, argv=argv@entry=0x7ffcc6602eb8)
    at ../sysdeps/nptl/libc_start_call_main.h:58
        self = <optimized out>
        result = <optimized out>
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {140723636678328, 7600382950360807596, 0, 
                140723636678368, 94233402840984, 139956231798816, -7601952175256176468, 
                -7499111522585741140}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 
              0x7ffcc6602eb8, 0x7ffcc6602eb8}, data = {prev = 0x0, cleanup = 0x0, 
              canceltype = -966775112}}}
        not_first_call = <optimized out>
#10 0x00007f4a18e58305 in __libc_start_main_impl (main=0x55b46c6e7d50, argc=4, 
    argv=0x7ffcc6602eb8, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, 
    stack_end=0x7ffcc6602ea8) at ../csu/libc-start.c:360
No locals.
#11 0x000055b46c6ec621 in ?? ()
```

<br />

`frame 0`의 `./lib/x86_64-linux-gnu/liblzma.so.5`에서 크래시가 발생하였을 것으로 추정할 수 있다. `rip` 부분의 어셈블리를 살펴보면, `call *%rax`가 문제가 발생한 파트인 듯 하다.

```cpp
(gdb) info frame
Stack level 0, frame at 0x7ffcc6601ea0:
 rip = 0x0; saved rip = 0x7f4a18c8f88f
 called by frame at 0x7ffcc6601fd0
 Arglist at 0x7ffcc6601e90, args: 
 Locals at 0x7ffcc6601e90, Previous frame's sp is 0x7ffcc6601ea0
 Saved registers:
  rip at 0x7ffcc6601e
(gdb) x/10i 0x7f4a18c8f88f-4
   0x7f4a18c8f88b:      mov    %esp,%edi
   0x7f4a18c8f88d:      call   *%rax
   0x7f4a18c8f88f:      mov    0xe8(%rsp),%rbx
   0x7f4a18c8f897:      xor    %fs:0x28,%rbx
   0x7f4a18c8f8a0:      jne    0x7f4a18c8f975
   0x7f4a18c8f8a6:      add    $0xf8,%rsp
   0x7f4a18c8f8ad:      pop    %rbx
   0x7f4a18c8f8ae:      pop    %rbp
   0x7f4a18c8f8af:      pop    %r12
   0x7f4a18c8f8b1:      pop    %r13
```

<br />


## 크래시 분석

`info proc map`을 통해 크래시 시점의 `rip`가 `Start Addr + 0x988F`임을 알 수 있다.

```cpp
(gdb) info proc mappings
Mapped address spaces:
      Start Addr           End Addr       Size     Offset objfile
      ...
      0x7f4a18c86000     0x7f4a18c8a000     0x4000        0x0 / (deleted)
      ...
```

<br />

`ida`로 `liblzma.so.5`를 연 후 `Start Addr + 0x988F` 부분에 앞서 찾았던 `
(gdb) x/10i 0x7f4a18c8f88f-4`와 동일한 어셈블리 파트가 존재한다. 이 부분의 디스어셈블리를 보면 아래와 같다. `RSA_public_decrypt`를 빙자한 백도어처럼 생겼다. 동작 구조를 대략적으로 요약하면 다음과 같다. 
1. `getuid()`, `0xC5407A48` : root 권한 및 백도어 매직 넘버 검사 
2. `sub_93F0`, `sub_9520` : `chacha20` `key, nonce` 초기화 및 `&unk_23960` 복호화
3.  `v13()` : 복호화된 데이터(백도어를 통한 원격 명령) 실행
4. `return v10(a1, a2, a3, a4, a5);` : 크래시가 발생한 포인트

```cpp
__int64 __fastcall sub_9820(unsigned int a1, _DWORD *a2, __int64 a3, __int64 a4, unsigned int a5)
{
  const char *v9; // rsi
  void *v10; // rax
  void *v12; // rax
  void (*v13)(void); // [rsp+8h] [rbp-120h]
  char v14[200]; // [rsp+20h] [rbp-108h] BYREF
  unsigned __int64 v15; // [rsp+E8h] [rbp-40h]

  v15 = __readfsqword(0x28u);
  v9 = "RSA_public_decrypt";
  if ( !getuid() )
  {
    if ( *a2 == 0xC5407A48 )
    {
      sub_93F0(v14, a2 + 1, a2 + 9, 0LL);
      v12 = mmap(0LL, dword_32360, 7, 34, -1, 0LL);
      v13 = (void (*)(void))memcpy(v12, &unk_23960, dword_32360);
      sub_9520(v14, v13, dword_32360);
      v13();
      sub_93F0(v14, a2 + 1, a2 + 9, 0LL);
      sub_9520(v14, v13, dword_32360);
    }
    v9 = "RSA_public_decrypt ";
  }
  v10 = dlsym(0LL, v9);
  return ((__int64 (__fastcall *)(_QWORD, _DWORD *, __int64, __int64, _QWORD))v10)(a1, a2, a3, a4, a5);
}
```

<br />

크래시가 발생한 부분의 `argument`는 다음과 같이 저장되므로, `a1~a5`를 다음의 레지스터에서 복구가 가능하다.

```cpp
.text:000000000000987E                 mov     r8d, ebx  //a5
.text:0000000000009881                 mov     rcx, r14  //a4
.text:0000000000009884                 mov     rdx, r13  //a3
.text:0000000000009887                 mov     rsi, rbp  //a2
.text:000000000000988A                 mov     edi, r12d //a1
.text:000000000000988D                 call    rax
```

<br />

그 중 `a2`는 `chacha20`에서 사용하는 상태 배열로 `key`와 `nonce`를 구할 수 있다. 
- 0[4] : 매직 넘버
- 4[32] :  `key`
- 8[12] : `nonce`

```cpp
(gdb) x/48bx $rsi
0x55b46d51dde0: 0x48    0x7a    0x40    0xc5    0x94    0x3d    0xf6    0x38
0x55b46d51dde8: 0xa8    0x18    0x13    0xe2    0xde    0x63    0x18    0xa5
0x55b46d51ddf0: 0x07    0xf9    0xa0    0xba    0x2d    0xbb    0x8a    0x7b
0x55b46d51ddf8: 0xa6    0x36    0x66    0xd0    0x8d    0x11    0xa6    0x5e
0x55b46d51de00: 0xc9    0x14    0xd6    0x6f    0xf2    0x36    0x83    0x9f
0x55b46d51de08: 0x4d    0xcd    0x71    0x1a    0x52    0x86    0x29    0x55
```

<br />

## 쉘코드
### 쉘코드 해석
다음과 같이 `unk_23960`을 복호화하면 쉘코드를 얻을 수 있다.

```python
from Crypto.Cipher import ChaCha20

def scd_decode():
    key_hex = "943df638a81813e2de6318a507f9a0ba2dbb8a7ba63666d08d11a65ec914d66f"
    nonce_hex = "f236839f4dcd711a52862955"
    key = bytes.fromhex(key_hex)
    nonce = bytes.fromhex(nonce_hex)
    
    with open("scd_encoded.dump","rb") as f:
        ciphertext = f.read()
    cipher = ChaCha20.new(key=key, nonce=nonce)
    plaintext = cipher.decrypt(ciphertext)
    
    with open("scd_decoded", "wb") as f:
        f.write(plaintext)
```

<br />

대략적으로 해석했을 때, 파일을 읽어 복호화하는 형태로 보인다. `string`에 `expand 32-byte K`가 존재하므로 앞선 암호화 방식과 동일하게 `ChaCha20` 방식을 사용 중인 것으로 추측된다. `ChaCha20` 에서는 `expand 32-byte k`를 상태 초기화를 위한 고정 상수로 사용하는 특징이 있기 때문이다. 다만, `k`가 아닌 `K`로 커스터마이징이 되어있다는 점을 주목할 필요가 있다. ~~풀이하는 입장에서 너무나 사탄스러운 부분이다.~~

```cpp
void __fastcall sub_DC2()
{
  unsigned int v0; // ebx
  unsigned __int64 v1; // kr08_8
  __int64 v2; // rcx
  char v3[32]; // [rsp+410h] [rbp-1278h] BYREF
  char v4[272]; // [rsp+430h] [rbp-1258h] BYREF
  char v5[4224]; // [rsp+540h] [rbp-1148h] BYREF
  unsigned int len_cipher; // [rsp+15C4h] [rbp-C4h]

  v0 = sub_1A();                                // fd manage
  __asm
  {
    syscall; Low latency system call            // 2d - brk
    syscall; Low latency system call
    syscall; Low latency system call
    syscall; Low latency system call
  }
  v4[61] = 0;
  __asm
  {
    syscall; Low latency system call            // 2 - open   
    syscall; Low latency system call            // 0 - read
  }
  v1 = strlen(v5) + 1;
  len_cipher = v1 - 1;
  sub_CD2((__int64)&v5[v1], (__int64)v5, v3, v4, 0LL);// key_init
  sub_D49((__int64)&v5[v1], (__int64)v5, (__int64)v5, len_cipher);// decode
  __asm
  {
    syscall; Low latency system call            // 2c - getppid
    syscall; Low latency system call
  }
  sub_B(v0, v5, len_cipher, v2, 0LL, 0LL);      // 3 - close
  sub_8F(v0, v5, 0LL);                          // 30 - sys_shutdown
}
```
<br />

특히 파일을 읽고 여는 부분을 보면 `rbp-0x1248`이 `filename`, `rbp-0x1148`이 읽은 내용을 저장하는 버퍼같다.
```cpp
movsxd  rax, eax
mov     [rbp+rax+var_1248], 0
lea     rdi, [rbp+var_1248]
push    2
pop     rax
xor     esi, esi
xor     edx, edx
syscall                 ; Low latency system call
mov     r12d, eax
lea     rsi, [rbp+var_1148]
xor     eax, eax
mov     edi, r12d
mov     edx, 80h
syscall                 ; Low latency system call
```

<br />

쉘코드를 해석한 결과를 정리해보면 아래와 같다.

```cpp
초기화 문자열 : `expand 32-byte K`
v3 [rbp-1278h] : 암호화 키(32바이트)
v4 [rbp-1258h] : Nonce(12바이트)
[rbp-0x1248] : filename
[rbp-0x1148] : buffer(content)
[rbp-C4h] : len_cipher
```

<br />

### 파일 복호화
`filename (rbp-0x1248)`을 찾아보자. `v13()`이라는 함수 `call`에 의한 실행 중이었으므로 현재 `rbp`가 크래시 시점의 `rsp` 근처일 것이라고 가정하고 `0x7ffcc6601e98-0x1248` 근처의 `string search` 결과를 살펴본다.

![image.png](/assets/img/writeups/202411/5_1.jpg)

<br />

`0x7FFCC6600C18+0x1248`이 실행 시점의 `rbp`이었던 것으로 볼 수 있다. 그러므로 이를 이용하여, 암호화 키, `Nonce`, `content`, `length` 모두 구할 수 있다.

```cpp
(gdb) set $v13_rbp=0x7FFCC6600C18+0x1248
(gdb) x/44x $v13_rbp-0x1278
0x7ffcc6600be8: 0x8d    0xec    0x91    0x12    0xeb    0x76    0x0e    0xda
0x7ffcc6600bf0: 0x7c    0x7d    0x87    0xa4    0x43    0x27    0x1c    0x35
0x7ffcc6600bf8: 0xd9    0xe0    0xcb    0x87    0x89    0x93    0xb4    0xd9
0x7ffcc6600c00: 0x04    0xae    0xf9    0x34    0xfa    0x21    0x66    0xd7
0x7ffcc6600c08: 0x11    0x11    0x11    0x11    0x11    0x11    0x11    0x11
0x7ffcc6600c10: 0x11    0x11    0x11    0x11
```

<br />

`ChaCha20` 복호화(`expand 32-byte K` 커스터마이징)을 구현하고 위 변수들을 대입하면 복호화된 평문에 `flag`가 존재한다. 만약 커스터마이징된 부분이 `expand 32-byte K` 만이 아니였다면 쉘코드에 대한 추가 해석 및 구현이 필요해서 너무 복잡했을 듯하다. ~~그나마 다행이다.~~
`supp1y_cha1n_sund4y@flare-on.com` 

```python
import struct
import os

# 회전 함수 정의
def rotl32(v, n):
    return ((v << n) & 0xffffffff) | (v >> (32 - n))

# 쿼터 라운드 함수 정의
def quarter_round(x, a, b, c, d):
    x[a] = (x[a] + x[b]) & 0xffffffff
    x[d] ^= x[a]
    x[d] = rotl32(x[d], 16)

    x[c] = (x[c] + x[d]) & 0xffffffff
    x[b] ^= x[c]
    x[b] = rotl32(x[b], 12)

    x[a] = (x[a] + x[b]) & 0xffffffff
    x[d] ^= x[a]
    x[d] = rotl32(x[d], 8)

    x[c] = (x[c] + x[d]) & 0xffffffff
    x[b] ^= x[c]
    x[b] = rotl32(x[b], 7)

# ChaCha20 블록 함수 정의
def chacha20_block(key, counter, nonce):
    # 초기 상태 설정
    constants = (b'expand 32-byte K') #CUTOMIZED!!!!
    key = struct.unpack('<8L', key)
    nonce = struct.unpack('<3L', nonce)

    state = [
        struct.unpack('<L', constants[i:i + 4])[0] for i in range(0, 16, 4)
    ] + list(key) + [counter] + list(nonce)

    # 상태 복사본 생성
    working_state = list(state)

    # 20 라운드 진행 (10번의 더블 라운드)
    for _ in range(10):
        # 열 라운드
        quarter_round(working_state, 0, 4, 8, 12)
        quarter_round(working_state, 1, 5, 9, 13)
        quarter_round(working_state, 2, 6, 10, 14)
        quarter_round(working_state, 3, 7, 11, 15)
        # 대각선 라운드
        quarter_round(working_state, 0, 5, 10, 15)
        quarter_round(working_state, 1, 6, 11, 12)
        quarter_round(working_state, 2, 7, 8, 13)
        quarter_round(working_state, 3, 4, 9, 14)

    # 최종 상태 계산
    block = [(working_state[i] + state[i]) & 0xffffffff for i in range(16)]
    return struct.pack('<16L', *block)

# ChaCha20 암호화 함수 정의
def chacha20_encrypt(key, counter, nonce, plaintext):
    key = key.ljust(32, b'\0')[:32]
    nonce = nonce.ljust(12, b'\0')[:12]
    ciphertext = b''

    for i in range(0, len(plaintext), 64):
        block = chacha20_block(key, counter, nonce)
        counter = (counter + 1) & 0xffffffff
        keystream = block[:len(plaintext[i:i+64])]
        ciphertext += bytes([p ^ k for p, k in zip(plaintext[i:i+64], keystream)])

    return ciphertext


if __name__ == "__main__":
    key = bytes.fromhex("8D EC 91 12 EB 76 0E DA 7C 7D 87 A4 43 27 1C 35 D9 E0 CB 87 89 93 B4 D9 04 AE F9 34 FA 21 66 D7".replace(" ", ""))
    nonce = bytes.fromhex("11 11 11 11 11 11 11 11 11 11 11 11".replace(" ", ""))    
    counter = 0
    with open("file_encoded.dump", "rb") as f:
        ciphertext = f.read()

    # 복호화
    decrypted = chacha20_encrypt(key, counter, nonce, ciphertext)
    print("Decrypted:", decrypted)
```